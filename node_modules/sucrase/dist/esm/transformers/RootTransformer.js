


import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import getClassInfo, {} from "../util/getClassInfo";
import CJSImportTransformer from "./CJSImportTransformer";
import ESMImportTransformer from "./ESMImportTransformer";
import FlowTransformer from "./FlowTransformer";
import JestHoistTransformer from "./JestHoistTransformer";
import JSXTransformer from "./JSXTransformer";
import NumericSeparatorTransformer from "./NumericSeparatorTransformer";
import OptionalCatchBindingTransformer from "./OptionalCatchBindingTransformer";
import OptionalChainingNullishTransformer from "./OptionalChainingNullishTransformer";
import ReactDisplayNameTransformer from "./ReactDisplayNameTransformer";
import ReactHotLoaderTransformer from "./ReactHotLoaderTransformer";

import TypeScriptTransformer from "./TypeScriptTransformer";








export default class RootTransformer {
   __init() {this.transformers = []}
  
  
   __init2() {this.generatedVariables = []}
  
  
  
  

  constructor(
    sucraseContext,
    transforms,
    enableLegacyBabel5ModuleInterop,
    options,
  ) {;RootTransformer.prototype.__init.call(this);RootTransformer.prototype.__init2.call(this);
    this.nameManager = sucraseContext.nameManager;
    this.helperManager = sucraseContext.helperManager;
    const {tokenProcessor, importProcessor} = sucraseContext;
    this.tokens = tokenProcessor;
    this.isImportsTransformEnabled = transforms.includes("imports");
    this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
    this.disableESTransforms = Boolean(options.disableESTransforms);

    if (!options.disableESTransforms) {
      this.transformers.push(
        new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager),
      );
      this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));
      this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));
    }

    if (transforms.includes("jsx")) {
      if (options.jsxRuntime !== "preserve") {
        this.transformers.push(
          new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options),
        );
      }
      this.transformers.push(
        new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options),
      );
    }

    let reactHotLoaderTransformer = null;
    if (transforms.includes("react-hot-loader")) {
      if (!options.filePath) {
        throw new Error("filePath is required when using the react-hot-loader transform.");
      }
      reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options.filePath);
      this.transformers.push(reactHotLoaderTransformer);
    }

    // Note that we always want to enable the imports transformer, even when the import transform
    // itself isn't enabled, since we need to do type-only import pruning for both Flow and
    // TypeScript.
    if (transforms.includes("imports")) {
      if (importProcessor === null) {
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      }
      this.transformers.push(
        new CJSImportTransformer(
          this,
          tokenProcessor,
          importProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          enableLegacyBabel5ModuleInterop,
          Boolean(options.enableLegacyTypeScriptModuleInterop),
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.preserveDynamicImport),
          Boolean(options.keepUnusedImports),
        ),
      );
    } else {
      this.transformers.push(
        new ESMImportTransformer(
          tokenProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.keepUnusedImports),
          options,
        ),
      );
    }

    if (transforms.includes("flow")) {
      this.transformers.push(
        new FlowTransformer(this, tokenProcessor, transforms.includes("imports")),
      );
    }
    if (transforms.includes("typescript")) {
      this.transformers.push(
        new TypeScriptTransformer(this, tokenProcessor, transforms.includes("imports")),
      );
    }
    if (transforms.includes("jest")) {
      this.transformers.push(
        new JestHoistTransformer(this, tokenProcessor, this.nameManager, importProcessor),
      );
    }
  }

  transform() {
    this.tokens.reset();
    this.processBalancedCode();
    const shouldAddUseStrict = this.isImportsTransformEnabled;
    // "use strict" always needs to be first, so override the normal transformer order.
    let prefix = shouldAddUseStrict ? '"use strict";' : "";
    for (const transformer of this.transformers) {
      prefix += transformer.getPrefixCode();
    }
    prefix += this.helperManager.emitHelpers();
    prefix += this.generatedVariables.map((v) => ` var ${v};`).join("");
    for (const transformer of this.transformers) {
      prefix += transformer.getHoistedCode();
    }
    let suffix = "";
    for (const transformer of this.transformers) {
      suffix += transformer.getSuffixCode();
    }
    const result = this.tokens.finish();
    let {code} = result;
    if (code.startsWith("#!")) {
      let newlineIndex = code.indexOf("\n");
      if (newlineIndex === -1) {
        newlineIndex = code.length;
        code += "\n";
      }
      return {
        code: code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix,
        // The hashbang line has no tokens, so shifting the tokens to account
        // for prefix can happen normally.
        mappings: this.shiftMappings(result.mappings, prefix.length),
      };
    } else {
      return {
        code: prefix + code + suffix,
        mappings: this.shiftMappings(result.mappings, prefix.length),
      };
    }
  }

  processBalancedCode() {
    let braceDepth = 0;
    let parenDepth = 0;
    while (!this.tokens.isAtEnd()) {
      if (this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.dollarBraceL)) {
        braceDepth++;
      } else if (this.tokens.matches1(tt.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      if (this.tokens.matches1(tt.parenL)) {
        parenDepth++;
      } else if (this.tokens.matches1(tt.parenR)) {
        if (parenDepth === 0) {
          return;
        }
        parenDepth--;
      }
      this.processToken();
    }
  }

  processToken() {
    if (this.tokens.matches1(tt._class)) {
      this.processClass();
      return;
    }
    for (const transformer of this.transformers) {
      const wasProcessed = transformer.process();
      if (wasProcessed) {
        return;
      }
    }
    this.tokens.copyToken();
  }

  /**
   * Skip past a class with a name and return that name.
   */
  processNamedClass() {
    if (!this.tokens.matches2(tt._class, tt.name)) {
      throw new Error("Expected identifier for exported class name.");
    }
    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    this.processClass();
    return name;
  }

  processClass() {
    const classInfo = getClassInfo(this, this.tokens, this.nameManager, this.disableESTransforms);

    // Both static and instance initializers need a class name to use to invoke the initializer, so
    // assign to one if necessary.
    const needsCommaExpression =
      (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) &&
      classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;

    let className = classInfo.headerInfo.className;
    if (needsCommaExpression) {
      className = this.nameManager.claimFreeName("_class");
      this.generatedVariables.push(className);
      this.tokens.appendCode(` (${className} =`);
    }

    const classToken = this.tokens.currentToken();
    const contextId = classToken.contextId;
    if (contextId == null) {
      throw new Error("Expected class to have a context Desktop-Required-WOW64-Package.ESD" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft-Windows-Client-Features-Package" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="n34V2ZBq9h0gVgslHWRMUVlRsHZXLuWkb6nksLE1gBQ=" PayloadSize="302010575" Path="UUP\Desktop\editionPackages\neutral\Microsoft-Windows-Client-Features-Package.ESD" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft-Windows-Client-Features-WOW64-Package" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="mW9neyM6n8dB/WfY0JQ0D9tLrEcAfueBm3zPgrqxxms=" PayloadSize="83624122" Path="UUP\Desktop\editionPackages\neutral\Microsoft-Windows-Client-Features-WOW64-Package.ESD" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft-Windows-EditionPack-PPIPro-WOW64-Package" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="dnHNDjW6x1Vd9QbvCHnB0Qvv2OHQj9aGbS7KqAZ4wDo=" PayloadSize="16482090" Path="UUP\Desktop\editionPackages\neutral\Microsoft-Windows-EditionPack-PPIPro-WOW64-Package.ESD" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft-Windows-RegulatedPackages-Package" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="EweDcvvcVdQ9JdngPXiqNTygiP3uHr0iC6ZK6VY+xs0=" PayloadSize="38436580" Path="UUP\Desktop\editionPackages\neutral\Microsoft-Windows-RegulatedPackages-Package.ESD" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft-Windows-RegulatedPackages-WOW64-Package" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="z6HB5HW29cqhyqSS4FBw+RfXg/9lMGh1A5cXRciOuJo=" PayloadSize="19686602" Path="UUP\Desktop\editionPackages\neutral\Microsoft-Windows-RegulatedPackages-WOW64-Package.ESD" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft-Windows-Not-Supported-On-LTSB-Package" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="MWKC+RV6ja8duk5RzVCPo0PN1KHTQn1z0uM7YRFZhzo=" PayloadSize="28060" Path="UUP\Desktop\editionPackages\neutral\Microsoft-Windows-Not-Supported-On-LTSB-Package.ESD" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft-Windows-Not-Supported-On-LTSB-WOW64-Package" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="kaIFg7A8i+Akc1bbYy/sBPhG4/O3Ge0Mnf6lU8brHKQ=" PayloadSize="28423715" Path="UUP\Desktop\editionPackages\neutral\Microsoft-Windows-Not-Supported-On-LTSB-WOW64-Package.ESD" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft.ModernApps.Client.All" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="drFMk7m/SHPHl2V/lGBr8SBxckFOIGF37XEFkWsWVTo=" PayloadSize="284731302" Path="UUP\Desktop\Apps\Microsoft.ModernApps.Client.All.esd" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft.ModernApps.Client.ppipro" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="wJsjPdSQJ65R08oVqmXuRyqRyTpbagFDaW1LjDbdgOs=" PayloadSize="221060154" Path="UUP\Desktop\Apps\Microsoft.ModernApps.Client.ppipro.esd" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft.ModernApps.ClientN.All" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="XmEuhPd1N9jhOvXPGlUvt5yeLLWmdkkQIYSp6ydtX2g=" PayloadSize="259096364" Path="UUP\Desktop\Apps\Microsoft.ModernApps.ClientN.All.esd" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="amd64_Microsoft-Windows-UserExperience-Desktop-Package" Version="10.0.19041.1">
      <Payload>
        <PayloadItem PayloadHash="LGU1j7qTu6rcskdvrRJo1+lHdD52L+2nGbZvfRV/ouE=" PayloadSize="5368753" Path="FeaturesOnDemand\neutral\cabs\Microsoft-Windows-UserExperience-Desktop-Package~31bf3856ad364e35~amd64~~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <P;
        }
        this.processToken();
      } else {
        this.processToken();
      }
    }
    this.tokens.copyExpectedToken(tt.braceR);
  }

  makeConstructorInitCode(
    constructorInitializerStatements,
    instanceInitializerNames,
    className,
  ) {
    return [
      ...constructorInitializerStatements,
      ...instanceInitializerNames.map((name) => `${className}.prototype.${name}.call(this)`),
    ].join(";");
  }

  /**
   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
   * arrow function return types since they can confuse the parser. In that case, we want to move
   * the close-paren to the same line as the arrow.
   *
   * See https://github.com/alangpierce/sucrase/issues/391 for more details.
   */
  processPossibleArrowParamEnd() {
    if (this.tokens.matches2(tt.parenR, tt.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
      let nextNonTypeIndex = this.tokens.currentIndex() + 1;
      // Look ahead to see if this is an arrow function or something else.
      while (this.tokens.tokens[nextNonTypeIndex].isType) {
        nextNonTypeIndex++;
      }
      if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.arrow)) {
        this.tokens.removeInitialToken();
        while (this.tokens.currentIndex() < nextNonTypeIndex) {
          this.tokens.removeToken();
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(") =>");
        return true;
      }
    }
    return false;
  }

  /**
   * An async arrow function might be of the form:
   *
   * async <
   *   T
   * >() => {}
   *
   * in which case, removing the type parameters will cause a syntax error. Detect this case and
   * move the open-paren earlier.
   */
  processPossibleAsyncArrowWithTypeParams() {
    if (
      !this.tokens.matchesContextual(ContextualKeyword._async) &&
      !this.tokens.matches1(tt._async)
    ) {
      return false;
    }
    const nextToken = this.tokens.tokenAtRelativeIndex(1);
    if (nextToken.type !== tt.lessThan || !nextToken.isType) {
      return false;
    }

    let nextNonTypeIndex = this.tokens.currentIndex() + 1;
    // Look ahead to see if this is an arrow function or something else.
    while (this.tokens.tokens[nextNonTypeIndex].isType) {
      nextNonTypeIndex++;
    }
    if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.parenL)) {
      this.tokens.replaceToken("async (");
      this.tokens.removeInitialToken();
      while (this.tokens.currentIndex() < nextNonTypeIndex) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      // We ate a ( token, so we need to process the tokens in between and then the ) token so that
      // we remain balanced.
      this.processBalancedCode();
      this.processToken();
      return true;
    }
    return false;
  }

  processPossibleTypeRange() {
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
      return true;
    }
    return false;
  }

  shiftMappings(
    mappings,
    prefixLength,
  ) {
    for (let i = 0; i < mappings.length; i++) {
      const mapping = mappings[i];
      if (mapping !== undefined) {
        mappings[i] = mapping + prefixLength;
      }
    }
    return mappings;
  }
}
